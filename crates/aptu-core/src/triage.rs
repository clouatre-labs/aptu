// SPDX-License-Identifier: Apache-2.0

use crate::ai::types::IssueDetails;
use tracing::debug;

/// Signature string used to identify Aptu-generated triage comments
pub const APTU_SIGNATURE: &str = "Generated by Aptu";

/// Status of whether an issue has already been triaged
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct TriageStatus {
    /// Whether the issue has triage-related labels
    pub has_labels: bool,
    /// Whether the issue has an Aptu-generated comment
    pub has_aptu_comment: bool,
    /// List of labels that indicate triage status
    pub label_names: Vec<String>,
}

impl TriageStatus {
    /// Create a new `TriageStatus`.
    #[must_use]
    pub fn new(has_labels: bool, has_aptu_comment: bool, label_names: Vec<String>) -> Self {
        Self {
            has_labels,
            has_aptu_comment,
            label_names,
        }
    }

    /// Check if the issue has been triaged (has labels or Aptu comment).
    #[must_use]
    pub fn is_triaged(&self) -> bool {
        self.has_labels || self.has_aptu_comment
    }
}

/// Check if an issue has already been triaged.
///
/// Returns `TriageStatus` indicating whether the issue has triage labels or Aptu comments.
pub fn check_already_triaged(issue: &IssueDetails) -> TriageStatus {
    // Check for triage-related labels
    const TRIAGE_LABELS: &[&str] = &[
        "bug",
        "enhancement",
        "documentation",
        "question",
        "good first issue",
        "help wanted",
        "duplicate",
        "invalid",
        "wontfix",
        "triaged",
        "needs-triage",
        "status: triaged",
    ];

    let has_labels = issue
        .labels
        .iter()
        .any(|label| TRIAGE_LABELS.contains(&label.as_str()));

    let label_names = issue
        .labels
        .iter()
        .filter(|label| TRIAGE_LABELS.contains(&label.as_str()))
        .cloned()
        .collect();

    // Check for Aptu signature in comments
    let has_aptu_comment = issue
        .comments
        .iter()
        .any(|comment| comment.body.contains(APTU_SIGNATURE));

    if has_labels || has_aptu_comment {
        debug!(
            has_labels = has_labels,
            has_aptu_comment = has_aptu_comment,
            labels = ?label_names,
            "Issue already triaged"
        );
    }

    TriageStatus::new(has_labels, has_aptu_comment, label_names)
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::ai::types::IssueComment;

    fn create_test_issue(labels: Vec<String>, comments: Vec<IssueComment>) -> IssueDetails {
        IssueDetails {
            owner: "test".to_string(),
            repo: "repo".to_string(),
            number: 1,
            title: "Test issue".to_string(),
            body: "Test body".to_string(),
            labels,
            comments,
            url: "https://github.com/test/repo/issues/1".to_string(),
            repo_context: Vec::new(),
            repo_tree: Vec::new(),
            available_labels: Vec::new(),
            available_milestones: Vec::new(),
            viewer_permission: None,
        }
    }

    #[test]
    fn test_no_triage() {
        let issue = create_test_issue(vec![], vec![]);
        let status = check_already_triaged(&issue);
        assert!(!status.is_triaged());
        assert!(!status.has_labels);
        assert!(!status.has_aptu_comment);
        assert!(status.label_names.is_empty());
    }

    #[test]
    fn test_labels_only() {
        let labels = vec!["bug".to_string(), "good first issue".to_string()];
        let issue = create_test_issue(labels, vec![]);
        let status = check_already_triaged(&issue);
        assert!(status.is_triaged());
        assert!(status.has_labels);
        assert!(!status.has_aptu_comment);
        assert_eq!(status.label_names.len(), 2);
        assert!(status.label_names.contains(&"bug".to_string()));
        assert!(status.label_names.contains(&"good first issue".to_string()));
    }

    #[test]
    fn test_aptu_comment_only() {
        let comments = vec![IssueComment {
            author: "aptu-bot".to_string(),
            body: "This looks good. Generated by Aptu".to_string(),
        }];
        let issue = create_test_issue(vec![], comments);
        let status = check_already_triaged(&issue);
        assert!(status.is_triaged());
        assert!(!status.has_labels);
        assert!(status.has_aptu_comment);
        assert!(status.label_names.is_empty());
    }

    #[test]
    fn test_both_labels_and_comment() {
        let labels = vec!["enhancement".to_string()];
        let comments = vec![IssueComment {
            author: "aptu-bot".to_string(),
            body: "Generated by Aptu".to_string(),
        }];
        let issue = create_test_issue(labels, comments);
        let status = check_already_triaged(&issue);
        assert!(status.is_triaged());
        assert!(status.has_labels);
        assert!(status.has_aptu_comment);
        assert_eq!(status.label_names.len(), 1);
    }

    #[test]
    fn test_partial_signature_no_match() {
        let comments = vec![IssueComment {
            author: "other-bot".to_string(),
            body: "Generated by AnotherTool".to_string(),
        }];
        let issue = create_test_issue(vec![], comments);
        let status = check_already_triaged(&issue);
        assert!(!status.is_triaged());
        assert!(!status.has_aptu_comment);
    }

    #[test]
    fn test_irrelevant_labels() {
        let labels = vec!["priority: high".to_string(), "component: ui".to_string()];
        let issue = create_test_issue(labels, vec![]);
        let status = check_already_triaged(&issue);
        assert!(!status.is_triaged());
        assert!(!status.has_labels);
        assert!(status.label_names.is_empty());
    }
}
