// SPDX-License-Identifier: Apache-2.0

//! Triage status detection for GitHub issues.
//!
//! This module provides utilities to check whether an issue has already been triaged,
//! either through labels or Aptu-generated comments.

use crate::ai::types::IssueDetails;
use tracing::debug;

/// Signature string used to identify Aptu-generated triage comments
pub const APTU_SIGNATURE: &str = "Generated by Aptu";

/// Status of whether an issue has already been triaged
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct TriageStatus {
    /// Whether the issue has a type label (bug, enhancement, etc.)
    pub has_type_label: bool,
    /// Whether the issue has a priority label (p0-p4, priority: high/medium/low)
    pub has_priority_label: bool,
    /// Whether the issue has an Aptu-generated comment
    pub has_aptu_comment: bool,
    /// List of labels that indicate triage status
    pub label_names: Vec<String>,
}

impl TriageStatus {
    /// Create a new `TriageStatus`.
    #[must_use]
    pub fn new(
        has_type_label: bool,
        has_priority_label: bool,
        has_aptu_comment: bool,
        label_names: Vec<String>,
    ) -> Self {
        Self {
            has_type_label,
            has_priority_label,
            has_aptu_comment,
            label_names,
        }
    }

    /// Check if the issue has been triaged (has both type and priority labels, or Aptu comment).
    #[must_use]
    pub fn is_triaged(&self) -> bool {
        (self.has_type_label && self.has_priority_label) || self.has_aptu_comment
    }
}

/// Check if a label is a type label (bug, enhancement, documentation, etc.).
fn is_type_label(label: &str) -> bool {
    const TYPE_LABELS: &[&str] = &[
        "bug",
        "enhancement",
        "documentation",
        "question",
        "good first issue",
        "help wanted",
        "duplicate",
        "invalid",
        "wontfix",
        "triaged",
        "needs-triage",
        "status: triaged",
    ];
    TYPE_LABELS.contains(&label)
}

/// Check if a label is a priority label (p0-p4 or priority: high/medium/low).
fn is_priority_label(label: &str) -> bool {
    let lower = label.to_lowercase();

    // Check for p[0-9] pattern (e.g., p0, p1, p2, p3, p4)
    if lower.len() == 2
        && lower.starts_with('p')
        && lower.chars().nth(1).is_some_and(|c| c.is_ascii_digit())
    {
        return true;
    }

    // Check for priority: prefix (e.g., priority: high, priority: medium, priority: low)
    if lower.starts_with("priority:") {
        let suffix = lower.strip_prefix("priority:").unwrap_or("").trim();
        return matches!(suffix, "high" | "medium" | "low");
    }

    false
}

/// Check if an issue has already been triaged.
///
/// Returns `TriageStatus` indicating whether the issue has both type and priority labels,
/// or has an Aptu-generated comment.
pub fn check_already_triaged(issue: &IssueDetails) -> TriageStatus {
    let has_type_label = issue.labels.iter().any(|label| is_type_label(label));
    let has_priority_label = issue.labels.iter().any(|label| is_priority_label(label));

    let label_names: Vec<String> = issue
        .labels
        .iter()
        .filter(|label| is_type_label(label) || is_priority_label(label))
        .cloned()
        .collect();

    // Check for Aptu signature in comments
    let has_aptu_comment = issue
        .comments
        .iter()
        .any(|comment| comment.body.contains(APTU_SIGNATURE));

    if has_type_label || has_priority_label || has_aptu_comment {
        debug!(
            has_type_label = has_type_label,
            has_priority_label = has_priority_label,
            has_aptu_comment = has_aptu_comment,
            labels = ?label_names,
            "Issue triage status detected"
        );
    }

    TriageStatus::new(
        has_type_label,
        has_priority_label,
        has_aptu_comment,
        label_names,
    )
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::ai::types::IssueComment;

    fn create_test_issue(labels: Vec<String>, comments: Vec<IssueComment>) -> IssueDetails {
        IssueDetails {
            owner: "test".to_string(),
            repo: "repo".to_string(),
            number: 1,
            title: "Test issue".to_string(),
            body: "Test body".to_string(),
            labels,
            milestone: None,
            comments,
            url: "https://github.com/test/repo/issues/1".to_string(),
            repo_context: Vec::new(),
            repo_tree: Vec::new(),
            available_labels: Vec::new(),
            available_milestones: Vec::new(),
            viewer_permission: None,
        }
    }

    #[test]
    fn test_no_triage() {
        let issue = create_test_issue(vec![], vec![]);
        let status = check_already_triaged(&issue);
        assert!(!status.is_triaged());
        assert!(!status.has_type_label);
        assert!(!status.has_priority_label);
        assert!(!status.has_aptu_comment);
        assert!(status.label_names.is_empty());
    }

    #[test]
    fn test_type_label_only() {
        let labels = vec!["bug".to_string()];
        let issue = create_test_issue(labels, vec![]);
        let status = check_already_triaged(&issue);
        assert!(!status.is_triaged());
        assert!(status.has_type_label);
        assert!(!status.has_priority_label);
        assert!(!status.has_aptu_comment);
        assert_eq!(status.label_names.len(), 1);
    }

    #[test]
    fn test_priority_label_only() {
        let labels = vec!["p1".to_string()];
        let issue = create_test_issue(labels, vec![]);
        let status = check_already_triaged(&issue);
        assert!(!status.is_triaged());
        assert!(!status.has_type_label);
        assert!(status.has_priority_label);
        assert!(!status.has_aptu_comment);
        assert_eq!(status.label_names.len(), 1);
    }

    #[test]
    fn test_type_and_priority_labels() {
        let labels = vec!["bug".to_string(), "p1".to_string()];
        let issue = create_test_issue(labels, vec![]);
        let status = check_already_triaged(&issue);
        assert!(status.is_triaged());
        assert!(status.has_type_label);
        assert!(status.has_priority_label);
        assert!(!status.has_aptu_comment);
        assert_eq!(status.label_names.len(), 2);
    }

    #[test]
    fn test_priority_prefix_labels() {
        // Test all priority: prefix variants (high, medium, low)
        for priority in ["priority: high", "priority: medium", "priority: low"] {
            let labels = vec!["bug".to_string(), priority.to_string()];
            let issue = create_test_issue(labels, vec![]);
            let status = check_already_triaged(&issue);
            assert!(status.is_triaged(), "Failed for {priority}");
            assert!(status.has_type_label, "Failed for {priority}");
            assert!(status.has_priority_label, "Failed for {priority}");
        }
    }

    #[test]
    fn test_aptu_comment_only() {
        let comments = vec![IssueComment {
            author: "aptu-bot".to_string(),
            body: "This looks good. Generated by Aptu".to_string(),
        }];
        let issue = create_test_issue(vec![], comments);
        let status = check_already_triaged(&issue);
        assert!(status.is_triaged());
        assert!(!status.has_type_label);
        assert!(!status.has_priority_label);
        assert!(status.has_aptu_comment);
        assert!(status.label_names.is_empty());
    }

    #[test]
    fn test_type_label_with_aptu_comment() {
        let labels = vec!["bug".to_string()];
        let comments = vec![IssueComment {
            author: "aptu-bot".to_string(),
            body: "Generated by Aptu".to_string(),
        }];
        let issue = create_test_issue(labels, comments);
        let status = check_already_triaged(&issue);
        assert!(status.is_triaged());
        assert!(status.has_type_label);
        assert!(!status.has_priority_label);
        assert!(status.has_aptu_comment);
    }

    #[test]
    fn test_partial_signature_no_match() {
        let comments = vec![IssueComment {
            author: "other-bot".to_string(),
            body: "Generated by AnotherTool".to_string(),
        }];
        let issue = create_test_issue(vec![], comments);
        let status = check_already_triaged(&issue);
        assert!(!status.is_triaged());
        assert!(!status.has_aptu_comment);
    }

    #[test]
    fn test_irrelevant_labels() {
        let labels = vec!["component: ui".to_string(), "needs-review".to_string()];
        let issue = create_test_issue(labels, vec![]);
        let status = check_already_triaged(&issue);
        assert!(!status.is_triaged());
        assert!(!status.has_type_label);
        assert!(!status.has_priority_label);
        assert!(status.label_names.is_empty());
    }

    #[test]
    fn test_priority_label_case_insensitive() {
        let labels = vec!["bug".to_string(), "P2".to_string()];
        let issue = create_test_issue(labels, vec![]);
        let status = check_already_triaged(&issue);
        assert!(status.is_triaged());
        assert!(status.has_priority_label);
    }

    #[test]
    fn test_priority_prefix_case_insensitive() {
        let labels = vec!["enhancement".to_string(), "Priority: HIGH".to_string()];
        let issue = create_test_issue(labels, vec![]);
        let status = check_already_triaged(&issue);
        assert!(status.is_triaged());
        assert!(status.has_priority_label);
    }
}
